/*
 * Core Capture Services
 * OpenText Core Capture Services are a set of RESTful web service interfaces that provides capture functionality. Being developed in a purely RESTful style, Core Capture Services are easier to consume for the purposes of writing custom clients.  Core Capture Services identifies resources by Uniform Resource Identifiers (URIs). It defines specific media types to represent resources and drives application state transfers by using link relations. It uses a limited number of HTTP standard methods (GET, POST, and DELETE) to manipulate these resources over the HTTP protocol.  Core Capture Services (hereafter simply called, \"service\") supports only the JSON format for resource representation. JavaScript Object Notation (JSON) is a lightweight data interchange format based on a subset of the JavaScript Programming Language standard.
 *
 * The version of the OpenAPI document: 23.3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.ot2.corecapture;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.ot2.corecapture.DocItemContentContentFieldsInnerUiControlInfo;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.ot2.JSON;

/**
 * DocItemContentContentFieldsInner
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2023-10-08T02:12:33.841201300+05:30[Asia/Calcutta]")
public class DocItemContentContentFieldsInner {
  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_IS_ARRAY = "isArray";
  @SerializedName(SERIALIZED_NAME_IS_ARRAY)
  private Boolean isArray;

  /**
   * Type of field (Number, String, Boolean, DateTime)
   */
  @JsonAdapter(IndexFieldTypeEnum.Adapter.class)
  public enum IndexFieldTypeEnum {
    NUMBER("Number"),
    
    STRING("String"),
    
    BOOLEAN("Boolean"),
    
    DATETIME("DateTime");

    private String value;

    IndexFieldTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static IndexFieldTypeEnum fromValue(String value) {
      for (IndexFieldTypeEnum b : IndexFieldTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<IndexFieldTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final IndexFieldTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public IndexFieldTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return IndexFieldTypeEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_INDEX_FIELD_TYPE = "indexFieldType";
  @SerializedName(SERIALIZED_NAME_INDEX_FIELD_TYPE)
  private IndexFieldTypeEnum indexFieldType;

  public static final String SERIALIZED_NAME_SECTION_NAME = "sectionName";
  @SerializedName(SERIALIZED_NAME_SECTION_NAME)
  private String sectionName;

  public static final String SERIALIZED_NAME_INDEX_LEVEL = "indexLevel";
  @SerializedName(SERIALIZED_NAME_INDEX_LEVEL)
  private Integer indexLevel;

  /**
   * Confirmation kind. One of NeverConfirm, AlwaysConfirm, ConfirmOnEmpty.
   */
  @JsonAdapter(ConfirmKindEnum.Adapter.class)
  public enum ConfirmKindEnum {
    NEVERCONFIRM("NeverConfirm"),
    
    ALWAYSCONFIRM("AlwaysConfirm"),
    
    CONFIRMONEMPTY("ConfirmOnEmpty");

    private String value;

    ConfirmKindEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ConfirmKindEnum fromValue(String value) {
      for (ConfirmKindEnum b : ConfirmKindEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ConfirmKindEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ConfirmKindEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ConfirmKindEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ConfirmKindEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_CONFIRM_KIND = "confirmKind";
  @SerializedName(SERIALIZED_NAME_CONFIRM_KIND)
  private ConfirmKindEnum confirmKind;

  public static final String SERIALIZED_NAME_IS_READ_ONLY = "isReadOnly";
  @SerializedName(SERIALIZED_NAME_IS_READ_ONLY)
  private Boolean isReadOnly;

  public static final String SERIALIZED_NAME_IS_REQURIED = "isRequried";
  @SerializedName(SERIALIZED_NAME_IS_REQURIED)
  private Boolean isRequried;

  public static final String SERIALIZED_NAME_MIN_VALUE = "minValue";
  @SerializedName(SERIALIZED_NAME_MIN_VALUE)
  private String minValue;

  public static final String SERIALIZED_NAME_MAX_VALUE = "maxValue";
  @SerializedName(SERIALIZED_NAME_MAX_VALUE)
  private String maxValue;

  public static final String SERIALIZED_NAME_RESTRICTION_MASK = "restrictionMask";
  @SerializedName(SERIALIZED_NAME_RESTRICTION_MASK)
  private String restrictionMask;

  public static final String SERIALIZED_NAME_VIEW_FORMAT = "viewFormat";
  @SerializedName(SERIALIZED_NAME_VIEW_FORMAT)
  private String viewFormat;

  public static final String SERIALIZED_NAME_CHECK_DATE_FROM_NOW = "checkDateFromNow";
  @SerializedName(SERIALIZED_NAME_CHECK_DATE_FROM_NOW)
  private Boolean checkDateFromNow;

  public static final String SERIALIZED_NAME_UI_CONTROL_INFO = "uiControlInfo";
  @SerializedName(SERIALIZED_NAME_UI_CONTROL_INFO)
  private DocItemContentContentFieldsInnerUiControlInfo uiControlInfo;

  public static final String SERIALIZED_NAME_IS_POPULATION_TRIGGER = "isPopulationTrigger";
  @SerializedName(SERIALIZED_NAME_IS_POPULATION_TRIGGER)
  private Boolean isPopulationTrigger;

  public static final String SERIALIZED_NAME_OPTIONS_POPULATED_BY = "optionsPopulatedBy";
  @SerializedName(SERIALIZED_NAME_OPTIONS_POPULATED_BY)
  private List<String> optionsPopulatedBy;

  public static final String SERIALIZED_NAME_EXTRACT_FIRST_VALUE = "extractFirstValue";
  @SerializedName(SERIALIZED_NAME_EXTRACT_FIRST_VALUE)
  private Boolean extractFirstValue;

  public static final String SERIALIZED_NAME_IS_CALCULATION_TARGET = "isCalculationTarget";
  @SerializedName(SERIALIZED_NAME_IS_CALCULATION_TARGET)
  private Boolean isCalculationTarget;

  public static final String SERIALIZED_NAME_SAMPLE_RECT = "sampleRect";
  @SerializedName(SERIALIZED_NAME_SAMPLE_RECT)
  private String sampleRect;

  public static final String SERIALIZED_NAME_SAMPLE_PAGE_ID = "samplePageId";
  @SerializedName(SERIALIZED_NAME_SAMPLE_PAGE_ID)
  private String samplePageId;

  public DocItemContentContentFieldsInner() {
  }

  public DocItemContentContentFieldsInner name(String name) {
    
    this.name = name;
    return this;
  }

   /**
   * Name of the field
   * @return name
  **/
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }


  public void setName(String name) {
    this.name = name;
  }


  public DocItemContentContentFieldsInner isArray(Boolean isArray) {
    
    this.isArray = isArray;
    return this;
  }

   /**
   * Whether the field is an array field.
   * @return isArray
  **/
  @javax.annotation.Nullable
  public Boolean getIsArray() {
    return isArray;
  }


  public void setIsArray(Boolean isArray) {
    this.isArray = isArray;
  }


  public DocItemContentContentFieldsInner indexFieldType(IndexFieldTypeEnum indexFieldType) {
    
    this.indexFieldType = indexFieldType;
    return this;
  }

   /**
   * Type of field (Number, String, Boolean, DateTime)
   * @return indexFieldType
  **/
  @javax.annotation.Nullable
  public IndexFieldTypeEnum getIndexFieldType() {
    return indexFieldType;
  }


  public void setIndexFieldType(IndexFieldTypeEnum indexFieldType) {
    this.indexFieldType = indexFieldType;
  }


  public DocItemContentContentFieldsInner sectionName(String sectionName) {
    
    this.sectionName = sectionName;
    return this;
  }

   /**
   * Form section name to which this field belongs. If field is an array type, then this is the table name.
   * @return sectionName
  **/
  @javax.annotation.Nullable
  public String getSectionName() {
    return sectionName;
  }


  public void setSectionName(String sectionName) {
    this.sectionName = sectionName;
  }


  public DocItemContentContentFieldsInner indexLevel(Integer indexLevel) {
    
    this.indexLevel = indexLevel;
    return this;
  }

   /**
   * Used only in the context of hierarchical collection of documents. The level must be between 1 and 7. If the level is higher than 1, then it is assumed that any changes must propagate to all siblings in the context of ancestor at that higher level.
   * @return indexLevel
  **/
  @javax.annotation.Nullable
  public Integer getIndexLevel() {
    return indexLevel;
  }


  public void setIndexLevel(Integer indexLevel) {
    this.indexLevel = indexLevel;
  }


  public DocItemContentContentFieldsInner confirmKind(ConfirmKindEnum confirmKind) {
    
    this.confirmKind = confirmKind;
    return this;
  }

   /**
   * Confirmation kind. One of NeverConfirm, AlwaysConfirm, ConfirmOnEmpty.
   * @return confirmKind
  **/
  @javax.annotation.Nullable
  public ConfirmKindEnum getConfirmKind() {
    return confirmKind;
  }


  public void setConfirmKind(ConfirmKindEnum confirmKind) {
    this.confirmKind = confirmKind;
  }


  public DocItemContentContentFieldsInner isReadOnly(Boolean isReadOnly) {
    
    this.isReadOnly = isReadOnly;
    return this;
  }

   /**
   * Is the field read only?
   * @return isReadOnly
  **/
  @javax.annotation.Nullable
  public Boolean getIsReadOnly() {
    return isReadOnly;
  }


  public void setIsReadOnly(Boolean isReadOnly) {
    this.isReadOnly = isReadOnly;
  }


  public DocItemContentContentFieldsInner isRequried(Boolean isRequried) {
    
    this.isRequried = isRequried;
    return this;
  }

   /**
   * Is this a required field?
   * @return isRequried
  **/
  @javax.annotation.Nullable
  public Boolean getIsRequried() {
    return isRequried;
  }


  public void setIsRequried(Boolean isRequried) {
    this.isRequried = isRequried;
  }


  public DocItemContentContentFieldsInner minValue(String minValue) {
    
    this.minValue = minValue;
    return this;
  }

   /**
   * Minimum value for the field. If null, no lower bound. In case of datetime, value is represented as double .NET OADate. In case of strings, min length.
   * @return minValue
  **/
  @javax.annotation.Nullable
  public String getMinValue() {
    return minValue;
  }


  public void setMinValue(String minValue) {
    this.minValue = minValue;
  }


  public DocItemContentContentFieldsInner maxValue(String maxValue) {
    
    this.maxValue = maxValue;
    return this;
  }

   /**
   * Maximum value for the field. If null, no upper bound. In case of datetime, value is represented as double .NET OADate. In case of strings, max length.
   * @return maxValue
  **/
  @javax.annotation.Nullable
  public String getMaxValue() {
    return maxValue;
  }


  public void setMaxValue(String maxValue) {
    this.maxValue = maxValue;
  }


  public DocItemContentContentFieldsInner restrictionMask(String restrictionMask) {
    
    this.restrictionMask = restrictionMask;
    return this;
  }

   /**
   * The Restriction mask pattern for validating strings. Empty means no pattern check. This is a regex expression equivalent to restriction mask pattern.
   * @return restrictionMask
  **/
  @javax.annotation.Nullable
  public String getRestrictionMask() {
    return restrictionMask;
  }


  public void setRestrictionMask(String restrictionMask) {
    this.restrictionMask = restrictionMask;
  }


  public DocItemContentContentFieldsInner viewFormat(String viewFormat) {
    
    this.viewFormat = viewFormat;
    return this;
  }

   /**
   * Holds the format string for date and time fields. The format string utilizes Microsoft .NET Framework 4.5.2 custom date and time format specifiers. Standard format strings are not supported. Example \&quot;dd-MM-yyyy hh:mm:ss tt\&quot; should be rendered by the client as, \&quot;27-10-2009 10:47:50 AM\&quot;.
   * @return viewFormat
  **/
  @javax.annotation.Nullable
  public String getViewFormat() {
    return viewFormat;
  }


  public void setViewFormat(String viewFormat) {
    this.viewFormat = viewFormat;
  }


  public DocItemContentContentFieldsInner checkDateFromNow(Boolean checkDateFromNow) {
    
    this.checkDateFromNow = checkDateFromNow;
    return this;
  }

   /**
   * If true and the datatype for the field is DateTime and range check is enabled through Min, Max values, the Min and Max values are interpreted as time span and are validated with reference to Now(). If false and the datatype is DateTime then Min and Max are interpreted as absolute date time values.
   * @return checkDateFromNow
  **/
  @javax.annotation.Nullable
  public Boolean getCheckDateFromNow() {
    return checkDateFromNow;
  }


  public void setCheckDateFromNow(Boolean checkDateFromNow) {
    this.checkDateFromNow = checkDateFromNow;
  }


  public DocItemContentContentFieldsInner uiControlInfo(DocItemContentContentFieldsInnerUiControlInfo uiControlInfo) {
    
    this.uiControlInfo = uiControlInfo;
    return this;
  }

   /**
   * Get uiControlInfo
   * @return uiControlInfo
  **/
  @javax.annotation.Nullable
  public DocItemContentContentFieldsInnerUiControlInfo getUiControlInfo() {
    return uiControlInfo;
  }


  public void setUiControlInfo(DocItemContentContentFieldsInnerUiControlInfo uiControlInfo) {
    this.uiControlInfo = uiControlInfo;
  }


  public DocItemContentContentFieldsInner isPopulationTrigger(Boolean isPopulationTrigger) {
    
    this.isPopulationTrigger = isPopulationTrigger;
    return this;
  }

   /**
   * If true, specifies that this field is a dependent field for one or more population rules in the Document Type definition. This will be false for only one-time rules.
   * @return isPopulationTrigger
  **/
  @javax.annotation.Nullable
  public Boolean getIsPopulationTrigger() {
    return isPopulationTrigger;
  }


  public void setIsPopulationTrigger(Boolean isPopulationTrigger) {
    this.isPopulationTrigger = isPopulationTrigger;
  }


  public DocItemContentContentFieldsInner optionsPopulatedBy(List<String> optionsPopulatedBy) {
    
    this.optionsPopulatedBy = optionsPopulatedBy;
    return this;
  }

  public DocItemContentContentFieldsInner addOptionsPopulatedByItem(String optionsPopulatedByItem) {
    if (this.optionsPopulatedBy == null) {
      this.optionsPopulatedBy = new ArrayList<>();
    }
    this.optionsPopulatedBy.add(optionsPopulatedByItem);
    return this;
  }

   /**
   * This is an array of string field names that when any of the fields specified changes, then it should cause the valid options for this field to change. This is not applicable for only one-time rules.
   * @return optionsPopulatedBy
  **/
  @javax.annotation.Nullable
  public List<String> getOptionsPopulatedBy() {
    return optionsPopulatedBy;
  }


  public void setOptionsPopulatedBy(List<String> optionsPopulatedBy) {
    this.optionsPopulatedBy = optionsPopulatedBy;
  }


  public DocItemContentContentFieldsInner extractFirstValue(Boolean extractFirstValue) {
    
    this.extractFirstValue = extractFirstValue;
    return this;
  }

   /**
   * If true, then document level extractions will use values from the first page where a non-empty value is found; otherwise, it will use the field from the last page where a non-empty value is found.
   * @return extractFirstValue
  **/
  @javax.annotation.Nullable
  public Boolean getExtractFirstValue() {
    return extractFirstValue;
  }


  public void setExtractFirstValue(Boolean extractFirstValue) {
    this.extractFirstValue = extractFirstValue;
  }


  public DocItemContentContentFieldsInner isCalculationTarget(Boolean isCalculationTarget) {
    
    this.isCalculationTarget = isCalculationTarget;
    return this;
  }

   /**
   * If true, specifies that this field is a data calculation target field. This will be false for only one-time rules.
   * @return isCalculationTarget
  **/
  @javax.annotation.Nullable
  public Boolean getIsCalculationTarget() {
    return isCalculationTarget;
  }


  public void setIsCalculationTarget(Boolean isCalculationTarget) {
    this.isCalculationTarget = isCalculationTarget;
  }


  public DocItemContentContentFieldsInner sampleRect(String sampleRect) {
    
    this.sampleRect = sampleRect;
    return this;
  }

   /**
   * Field Sample rectangle indicating field position in an image. A comma separated list of double values for left, top, width and height. All values are in units of 1/96 inch
   * @return sampleRect
  **/
  @javax.annotation.Nullable
  public String getSampleRect() {
    return sampleRect;
  }


  public void setSampleRect(String sampleRect) {
    this.sampleRect = sampleRect;
  }


  public DocItemContentContentFieldsInner samplePageId(String samplePageId) {
    
    this.samplePageId = samplePageId;
    return this;
  }

   /**
   * Field sample page id.
   * @return samplePageId
  **/
  @javax.annotation.Nullable
  public String getSamplePageId() {
    return samplePageId;
  }


  public void setSamplePageId(String samplePageId) {
    this.samplePageId = samplePageId;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DocItemContentContentFieldsInner docItemContentContentFieldsInner = (DocItemContentContentFieldsInner) o;
    return Objects.equals(this.name, docItemContentContentFieldsInner.name) &&
        Objects.equals(this.isArray, docItemContentContentFieldsInner.isArray) &&
        Objects.equals(this.indexFieldType, docItemContentContentFieldsInner.indexFieldType) &&
        Objects.equals(this.sectionName, docItemContentContentFieldsInner.sectionName) &&
        Objects.equals(this.indexLevel, docItemContentContentFieldsInner.indexLevel) &&
        Objects.equals(this.confirmKind, docItemContentContentFieldsInner.confirmKind) &&
        Objects.equals(this.isReadOnly, docItemContentContentFieldsInner.isReadOnly) &&
        Objects.equals(this.isRequried, docItemContentContentFieldsInner.isRequried) &&
        Objects.equals(this.minValue, docItemContentContentFieldsInner.minValue) &&
        Objects.equals(this.maxValue, docItemContentContentFieldsInner.maxValue) &&
        Objects.equals(this.restrictionMask, docItemContentContentFieldsInner.restrictionMask) &&
        Objects.equals(this.viewFormat, docItemContentContentFieldsInner.viewFormat) &&
        Objects.equals(this.checkDateFromNow, docItemContentContentFieldsInner.checkDateFromNow) &&
        Objects.equals(this.uiControlInfo, docItemContentContentFieldsInner.uiControlInfo) &&
        Objects.equals(this.isPopulationTrigger, docItemContentContentFieldsInner.isPopulationTrigger) &&
        Objects.equals(this.optionsPopulatedBy, docItemContentContentFieldsInner.optionsPopulatedBy) &&
        Objects.equals(this.extractFirstValue, docItemContentContentFieldsInner.extractFirstValue) &&
        Objects.equals(this.isCalculationTarget, docItemContentContentFieldsInner.isCalculationTarget) &&
        Objects.equals(this.sampleRect, docItemContentContentFieldsInner.sampleRect) &&
        Objects.equals(this.samplePageId, docItemContentContentFieldsInner.samplePageId);
  }

  @Override
  public int hashCode() {
    return Objects.hash(name, isArray, indexFieldType, sectionName, indexLevel, confirmKind, isReadOnly, isRequried, minValue, maxValue, restrictionMask, viewFormat, checkDateFromNow, uiControlInfo, isPopulationTrigger, optionsPopulatedBy, extractFirstValue, isCalculationTarget, sampleRect, samplePageId);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DocItemContentContentFieldsInner {\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    isArray: ").append(toIndentedString(isArray)).append("\n");
    sb.append("    indexFieldType: ").append(toIndentedString(indexFieldType)).append("\n");
    sb.append("    sectionName: ").append(toIndentedString(sectionName)).append("\n");
    sb.append("    indexLevel: ").append(toIndentedString(indexLevel)).append("\n");
    sb.append("    confirmKind: ").append(toIndentedString(confirmKind)).append("\n");
    sb.append("    isReadOnly: ").append(toIndentedString(isReadOnly)).append("\n");
    sb.append("    isRequried: ").append(toIndentedString(isRequried)).append("\n");
    sb.append("    minValue: ").append(toIndentedString(minValue)).append("\n");
    sb.append("    maxValue: ").append(toIndentedString(maxValue)).append("\n");
    sb.append("    restrictionMask: ").append(toIndentedString(restrictionMask)).append("\n");
    sb.append("    viewFormat: ").append(toIndentedString(viewFormat)).append("\n");
    sb.append("    checkDateFromNow: ").append(toIndentedString(checkDateFromNow)).append("\n");
    sb.append("    uiControlInfo: ").append(toIndentedString(uiControlInfo)).append("\n");
    sb.append("    isPopulationTrigger: ").append(toIndentedString(isPopulationTrigger)).append("\n");
    sb.append("    optionsPopulatedBy: ").append(toIndentedString(optionsPopulatedBy)).append("\n");
    sb.append("    extractFirstValue: ").append(toIndentedString(extractFirstValue)).append("\n");
    sb.append("    isCalculationTarget: ").append(toIndentedString(isCalculationTarget)).append("\n");
    sb.append("    sampleRect: ").append(toIndentedString(sampleRect)).append("\n");
    sb.append("    samplePageId: ").append(toIndentedString(samplePageId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("name");
    openapiFields.add("isArray");
    openapiFields.add("indexFieldType");
    openapiFields.add("sectionName");
    openapiFields.add("indexLevel");
    openapiFields.add("confirmKind");
    openapiFields.add("isReadOnly");
    openapiFields.add("isRequried");
    openapiFields.add("minValue");
    openapiFields.add("maxValue");
    openapiFields.add("restrictionMask");
    openapiFields.add("viewFormat");
    openapiFields.add("checkDateFromNow");
    openapiFields.add("uiControlInfo");
    openapiFields.add("isPopulationTrigger");
    openapiFields.add("optionsPopulatedBy");
    openapiFields.add("extractFirstValue");
    openapiFields.add("isCalculationTarget");
    openapiFields.add("sampleRect");
    openapiFields.add("samplePageId");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to DocItemContentContentFieldsInner
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DocItemContentContentFieldsInner.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DocItemContentContentFieldsInner is not found in the empty JSON string", DocItemContentContentFieldsInner.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DocItemContentContentFieldsInner.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DocItemContentContentFieldsInner` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("indexFieldType") != null && !jsonObj.get("indexFieldType").isJsonNull()) && !jsonObj.get("indexFieldType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `indexFieldType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("indexFieldType").toString()));
      }
      if ((jsonObj.get("sectionName") != null && !jsonObj.get("sectionName").isJsonNull()) && !jsonObj.get("sectionName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sectionName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sectionName").toString()));
      }
      if ((jsonObj.get("confirmKind") != null && !jsonObj.get("confirmKind").isJsonNull()) && !jsonObj.get("confirmKind").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `confirmKind` to be a primitive type in the JSON string but got `%s`", jsonObj.get("confirmKind").toString()));
      }
      if ((jsonObj.get("minValue") != null && !jsonObj.get("minValue").isJsonNull()) && !jsonObj.get("minValue").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `minValue` to be a primitive type in the JSON string but got `%s`", jsonObj.get("minValue").toString()));
      }
      if ((jsonObj.get("maxValue") != null && !jsonObj.get("maxValue").isJsonNull()) && !jsonObj.get("maxValue").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maxValue` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maxValue").toString()));
      }
      if ((jsonObj.get("restrictionMask") != null && !jsonObj.get("restrictionMask").isJsonNull()) && !jsonObj.get("restrictionMask").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `restrictionMask` to be a primitive type in the JSON string but got `%s`", jsonObj.get("restrictionMask").toString()));
      }
      if ((jsonObj.get("viewFormat") != null && !jsonObj.get("viewFormat").isJsonNull()) && !jsonObj.get("viewFormat").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `viewFormat` to be a primitive type in the JSON string but got `%s`", jsonObj.get("viewFormat").toString()));
      }
      // validate the optional field `uiControlInfo`
      if (jsonObj.get("uiControlInfo") != null && !jsonObj.get("uiControlInfo").isJsonNull()) {
        DocItemContentContentFieldsInnerUiControlInfo.validateJsonElement(jsonObj.get("uiControlInfo"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("optionsPopulatedBy") != null && !jsonObj.get("optionsPopulatedBy").isJsonNull() && !jsonObj.get("optionsPopulatedBy").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `optionsPopulatedBy` to be an array in the JSON string but got `%s`", jsonObj.get("optionsPopulatedBy").toString()));
      }
      if ((jsonObj.get("sampleRect") != null && !jsonObj.get("sampleRect").isJsonNull()) && !jsonObj.get("sampleRect").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sampleRect` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sampleRect").toString()));
      }
      if ((jsonObj.get("samplePageId") != null && !jsonObj.get("samplePageId").isJsonNull()) && !jsonObj.get("samplePageId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `samplePageId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("samplePageId").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DocItemContentContentFieldsInner.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DocItemContentContentFieldsInner' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DocItemContentContentFieldsInner> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DocItemContentContentFieldsInner.class));

       return (TypeAdapter<T>) new TypeAdapter<DocItemContentContentFieldsInner>() {
           @Override
           public void write(JsonWriter out, DocItemContentContentFieldsInner value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DocItemContentContentFieldsInner read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of DocItemContentContentFieldsInner given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of DocItemContentContentFieldsInner
  * @throws IOException if the JSON string is invalid with respect to DocItemContentContentFieldsInner
  */
  public static DocItemContentContentFieldsInner fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DocItemContentContentFieldsInner.class);
  }

 /**
  * Convert an instance of DocItemContentContentFieldsInner to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

