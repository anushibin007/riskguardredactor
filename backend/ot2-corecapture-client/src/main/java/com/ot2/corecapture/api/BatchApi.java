/*
 * Core Capture Services
 * OpenText Core Capture Services are a set of RESTful web service interfaces that provides capture functionality. Being developed in a purely RESTful style, Core Capture Services are easier to consume for the purposes of writing custom clients.  Core Capture Services identifies resources by Uniform Resource Identifiers (URIs). It defines specific media types to represent resources and drives application state transfers by using link relations. It uses a limited number of HTTP standard methods (GET, POST, and DELETE) to manipulate these resources over the HTTP protocol.  Core Capture Services (hereafter simply called, \"service\") supports only the JSON format for resource representation. JavaScript Object Notation (JSON) is a lightweight data interchange format based on a subset of the JavaScript Programming Language standard.
 *
 * The version of the OpenAPI document: 23.3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.ot2.corecapture.api;

import com.ot2.corecapture.invoker.ApiCallback;
import com.ot2.corecapture.invoker.ApiClient;
import com.ot2.corecapture.invoker.ApiException;
import com.ot2.corecapture.invoker.ApiResponse;
import com.ot2.corecapture.invoker.Configuration;
import com.ot2.corecapture.invoker.Pair;
import com.ot2.corecapture.invoker.ProgressRequestBody;
import com.ot2.corecapture.invoker.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.ot2.corecapture.model.Get415Response;
import com.ot2.corecapture.model.SessionBatchesPost201Response;
import com.ot2.corecapture.model.SessionBatchesPostRequest;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class BatchApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public BatchApi() {
        this(Configuration.getDefaultApiClient());
    }

    public BatchApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for sessionBatchesPost
     * @param sessionBatchesPostRequest  (required)
     * @param suppressResponseCodes This can be left without an assignment or you can use itself, suppress_response_codes&#x3D;suppress_response_codes (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> Unsupported Media Type </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call sessionBatchesPostCall(SessionBatchesPostRequest sessionBatchesPostRequest, String suppressResponseCodes, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = sessionBatchesPostRequest;

        // create path and map variables
        String localVarPath = "/session/batches";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (suppressResponseCodes != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("suppress_response_codes", suppressResponseCodes));
        }

        final String[] localVarAccepts = {
            "application/hal+json",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "na-1-dev.api.opentext.com" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call sessionBatchesPostValidateBeforeCall(SessionBatchesPostRequest sessionBatchesPostRequest, String suppressResponseCodes, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'sessionBatchesPostRequest' is set
        if (sessionBatchesPostRequest == null) {
            throw new ApiException("Missing the required parameter 'sessionBatchesPostRequest' when calling sessionBatchesPost(Async)");
        }

        return sessionBatchesPostCall(sessionBatchesPostRequest, suppressResponseCodes, _callback);

    }

    /**
     * Creates and exports a batch.
     * The Create and Export Batch operation is the last call required to create a batch and submit it to your backend server. First submit all image files to server, then you can use the returned file reference ids to reference files in the Batch nodal information. You can also use the same file reference ids returned by Real-Time service calls.  The batch name that you use to create a batch has to be unique when being imported into your backend server. To help you accomplish creating unique names you can supply for the \&quot;batchName\&quot; JSON property any Capture Services Format Expression function (see the Designer Documentation). There are also two additional format tokens you can use for providing unique names - {NextIndex} and {NextId}  **{NextIndex}** - This will provide a 64 bit integer number that is unique. Example: \&quot;batchName\&quot;:\&quot;MyBatch_{NextIndex}\&quot; produces on the server MyBatch_1026000000002  **{NextId}** - This will provide a valid Batch name string that is unique. Example: \&quot;batchName\&quot;:\&quot;MyBatch_{NextId}\&quot; produces on the server MyBatch_324_1  Any supported static function in the Capture Services Expression Language (see the Designer Documentation). [&lt;any text&gt;]{[&lt;Format Specification&gt;|]&lt;Expression&gt;}[&lt;any text&gt;] - Using the expression language functions can allow the user of a GUID or unique time string to be a part of the Batch Name. Example: \&quot;batchName\&quot;:\&quot;MyBatch_{Tddhhmmss|Now()}_{NextIndex}\&quot; produces on the server, MyBatch_09064934_1026000000003. Or \&quot;batchName\&quot;:\&quot;MyBatch_{S|CreateGuid(0)}\&quot; produces on the server, MyBatch_82fcd238-2fb7-44ac-9acc-a13ce406241d  **Document type and UimData values in batch:**  For composing export profile and exporting UimData values, Document type and UimData values must at batch level mentioned below with given names as below.  **Batch – Level 7:**  valueName &#x3D; \&quot;Profile \&quot;  valueType &#x3D; \&quot;string\&quot;  value &#x3D; // Name of the profile.  **Document – Level 1:**  valueName &#x3D; \&quot;UimDocumentType\&quot;  valueType &#x3D; \&quot;string\&quot;  value &#x3D; // This should be a string specifying the document type name.  valueName &#x3D; \&quot;UimData\&quot;  valueType &#x3D; \&quot;uimdata\&quot;  value &#x3D; // This should be a UIM Data JSON Object  valueName &#x3D; \&quot;OutputFile \&quot;  valueType &#x3D; \&quot; file\&quot;  value &#x3D; // File id for the original PDF to be available for export.  **Page – Level 0:**  valueName &#x3D; \&quot;OutputImage\&quot;  valueType &#x3D; \&quot;file\&quot;  value &#x3D; // file id for the image to be exported  valueName &#x3D; \&quot;Backside\&quot;  valueType &#x3D; \&quot;int\&quot;  value &#x3D; // 0 (front) or 1 (back) to indicate whether the image is a backside image.
     * @param sessionBatchesPostRequest  (required)
     * @param suppressResponseCodes This can be left without an assignment or you can use itself, suppress_response_codes&#x3D;suppress_response_codes (optional)
     * @return SessionBatchesPost201Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> Unsupported Media Type </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public SessionBatchesPost201Response sessionBatchesPost(SessionBatchesPostRequest sessionBatchesPostRequest, String suppressResponseCodes) throws ApiException {
        ApiResponse<SessionBatchesPost201Response> localVarResp = sessionBatchesPostWithHttpInfo(sessionBatchesPostRequest, suppressResponseCodes);
        return localVarResp.getData();
    }

    /**
     * Creates and exports a batch.
     * The Create and Export Batch operation is the last call required to create a batch and submit it to your backend server. First submit all image files to server, then you can use the returned file reference ids to reference files in the Batch nodal information. You can also use the same file reference ids returned by Real-Time service calls.  The batch name that you use to create a batch has to be unique when being imported into your backend server. To help you accomplish creating unique names you can supply for the \&quot;batchName\&quot; JSON property any Capture Services Format Expression function (see the Designer Documentation). There are also two additional format tokens you can use for providing unique names - {NextIndex} and {NextId}  **{NextIndex}** - This will provide a 64 bit integer number that is unique. Example: \&quot;batchName\&quot;:\&quot;MyBatch_{NextIndex}\&quot; produces on the server MyBatch_1026000000002  **{NextId}** - This will provide a valid Batch name string that is unique. Example: \&quot;batchName\&quot;:\&quot;MyBatch_{NextId}\&quot; produces on the server MyBatch_324_1  Any supported static function in the Capture Services Expression Language (see the Designer Documentation). [&lt;any text&gt;]{[&lt;Format Specification&gt;|]&lt;Expression&gt;}[&lt;any text&gt;] - Using the expression language functions can allow the user of a GUID or unique time string to be a part of the Batch Name. Example: \&quot;batchName\&quot;:\&quot;MyBatch_{Tddhhmmss|Now()}_{NextIndex}\&quot; produces on the server, MyBatch_09064934_1026000000003. Or \&quot;batchName\&quot;:\&quot;MyBatch_{S|CreateGuid(0)}\&quot; produces on the server, MyBatch_82fcd238-2fb7-44ac-9acc-a13ce406241d  **Document type and UimData values in batch:**  For composing export profile and exporting UimData values, Document type and UimData values must at batch level mentioned below with given names as below.  **Batch – Level 7:**  valueName &#x3D; \&quot;Profile \&quot;  valueType &#x3D; \&quot;string\&quot;  value &#x3D; // Name of the profile.  **Document – Level 1:**  valueName &#x3D; \&quot;UimDocumentType\&quot;  valueType &#x3D; \&quot;string\&quot;  value &#x3D; // This should be a string specifying the document type name.  valueName &#x3D; \&quot;UimData\&quot;  valueType &#x3D; \&quot;uimdata\&quot;  value &#x3D; // This should be a UIM Data JSON Object  valueName &#x3D; \&quot;OutputFile \&quot;  valueType &#x3D; \&quot; file\&quot;  value &#x3D; // File id for the original PDF to be available for export.  **Page – Level 0:**  valueName &#x3D; \&quot;OutputImage\&quot;  valueType &#x3D; \&quot;file\&quot;  value &#x3D; // file id for the image to be exported  valueName &#x3D; \&quot;Backside\&quot;  valueType &#x3D; \&quot;int\&quot;  value &#x3D; // 0 (front) or 1 (back) to indicate whether the image is a backside image.
     * @param sessionBatchesPostRequest  (required)
     * @param suppressResponseCodes This can be left without an assignment or you can use itself, suppress_response_codes&#x3D;suppress_response_codes (optional)
     * @return ApiResponse&lt;SessionBatchesPost201Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> Unsupported Media Type </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SessionBatchesPost201Response> sessionBatchesPostWithHttpInfo(SessionBatchesPostRequest sessionBatchesPostRequest, String suppressResponseCodes) throws ApiException {
        okhttp3.Call localVarCall = sessionBatchesPostValidateBeforeCall(sessionBatchesPostRequest, suppressResponseCodes, null);
        Type localVarReturnType = new TypeToken<SessionBatchesPost201Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Creates and exports a batch. (asynchronously)
     * The Create and Export Batch operation is the last call required to create a batch and submit it to your backend server. First submit all image files to server, then you can use the returned file reference ids to reference files in the Batch nodal information. You can also use the same file reference ids returned by Real-Time service calls.  The batch name that you use to create a batch has to be unique when being imported into your backend server. To help you accomplish creating unique names you can supply for the \&quot;batchName\&quot; JSON property any Capture Services Format Expression function (see the Designer Documentation). There are also two additional format tokens you can use for providing unique names - {NextIndex} and {NextId}  **{NextIndex}** - This will provide a 64 bit integer number that is unique. Example: \&quot;batchName\&quot;:\&quot;MyBatch_{NextIndex}\&quot; produces on the server MyBatch_1026000000002  **{NextId}** - This will provide a valid Batch name string that is unique. Example: \&quot;batchName\&quot;:\&quot;MyBatch_{NextId}\&quot; produces on the server MyBatch_324_1  Any supported static function in the Capture Services Expression Language (see the Designer Documentation). [&lt;any text&gt;]{[&lt;Format Specification&gt;|]&lt;Expression&gt;}[&lt;any text&gt;] - Using the expression language functions can allow the user of a GUID or unique time string to be a part of the Batch Name. Example: \&quot;batchName\&quot;:\&quot;MyBatch_{Tddhhmmss|Now()}_{NextIndex}\&quot; produces on the server, MyBatch_09064934_1026000000003. Or \&quot;batchName\&quot;:\&quot;MyBatch_{S|CreateGuid(0)}\&quot; produces on the server, MyBatch_82fcd238-2fb7-44ac-9acc-a13ce406241d  **Document type and UimData values in batch:**  For composing export profile and exporting UimData values, Document type and UimData values must at batch level mentioned below with given names as below.  **Batch – Level 7:**  valueName &#x3D; \&quot;Profile \&quot;  valueType &#x3D; \&quot;string\&quot;  value &#x3D; // Name of the profile.  **Document – Level 1:**  valueName &#x3D; \&quot;UimDocumentType\&quot;  valueType &#x3D; \&quot;string\&quot;  value &#x3D; // This should be a string specifying the document type name.  valueName &#x3D; \&quot;UimData\&quot;  valueType &#x3D; \&quot;uimdata\&quot;  value &#x3D; // This should be a UIM Data JSON Object  valueName &#x3D; \&quot;OutputFile \&quot;  valueType &#x3D; \&quot; file\&quot;  value &#x3D; // File id for the original PDF to be available for export.  **Page – Level 0:**  valueName &#x3D; \&quot;OutputImage\&quot;  valueType &#x3D; \&quot;file\&quot;  value &#x3D; // file id for the image to be exported  valueName &#x3D; \&quot;Backside\&quot;  valueType &#x3D; \&quot;int\&quot;  value &#x3D; // 0 (front) or 1 (back) to indicate whether the image is a backside image.
     * @param sessionBatchesPostRequest  (required)
     * @param suppressResponseCodes This can be left without an assignment or you can use itself, suppress_response_codes&#x3D;suppress_response_codes (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> Unsupported Media Type </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call sessionBatchesPostAsync(SessionBatchesPostRequest sessionBatchesPostRequest, String suppressResponseCodes, final ApiCallback<SessionBatchesPost201Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = sessionBatchesPostValidateBeforeCall(sessionBatchesPostRequest, suppressResponseCodes, _callback);
        Type localVarReturnType = new TypeToken<SessionBatchesPost201Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
